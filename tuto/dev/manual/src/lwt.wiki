<<header| = Lwt in 5 minutes >>

== Principle

The Lwt library implements cooperative threads for OCaml.
Cooperative threads are an alternative to preemptive threads (used
in many languages and in OCaml's {{{Thread}}} module), that solves
most usual issues of preemptive threads: very few risks of deadlocks,
very need of locks.
Lwt threads are even usable in programs compiled to JavaScript
using Js_of_ocaml.

Lwt is based on the fact that most program spend most of their time
waiting for inputs (keys, data coming from a socket, mouse events, etc).
Instead of using a preemptive scheduler, that switches from one thread
to another at arbitrary moments, it uses these waiting times, as
//cooperation points//. This means that instead of blocking (for example
on a {{{read}}}), Lwt will resume another waiting thread (if one is ready
to continue). All you have to do is to use the cooperative version of
each blocking function, for example {{{Lwt_unix.sleep}}} or {{{Lwt_unix.read}}}
instead of {{{Unix.sleep}}} or {{{Unix.read}}}.
If one of your computations takes a lot of time, it is also possible
to insert manually cooperation points using function {{{Lwt_main.yield}}}.

== Promises

Lwt defines one type {{{'a Lwt.t}}}, which is the type of promises.
For example, a function:

<<code language="ocaml"|
val f : unit -> int Lwt.t
>>

returns immediately a promise of {{{int}}}, that is, something that
will eventually become an integer once the computation is finished.

The following code will launch the computation of {{{f ()}}}
(asynchronously). If it reaches a cooperation point (for example the integer
comes from a network connection), it will continue the program (print "hello")
and resume at a subsequent cooperation point, when the data is available.
<<code language="ocaml"|
let g1 () =
  let p = f () in
  print_endline "hello"
>>

== Bind: Using the value of promises

It is possible to tell Lwt to execute a function once a promise is completed,
by using function:

<<code language="ocaml"|
Lwt.bind : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
>>

For instance
{{{Lwt.bind p h}}}
will call function {{{h}}} with the return value of promise {{{p}}}
as soon as it is known.
The expression {{{(Lwt.bind p h)}}} is also a promise (it may take time
to complete). Function {{{h}}} must return a promise.

To create a (terminated) promise from a value, use {{{Lwt.return}}}.

Example:
<<code language="ocaml"|
let g2 () =
  let p = f () in
  Lwt.bind p (fun i -> print_int i; Lwt.return ())
>>
Function {{{g2}}} calls function {{{f}}} to create a promise.
Then it waits (in cooperative manner) the result,
and prints it. The expression {{{g2 ()}}} has type {{{unit Lwt.t}}}.


== Syntax extension

A PPX (and also camlp4) syntax extension is available.

<<code language="ocaml"|
let%lwt i = f () in
...
>>

is equivalent to

<<code language="ocaml"|
Lwt.bind (f ()) (fun i -> ...)
>>

== Examples

=== A function that prints "tic" every second forever, without blocking the rest of the program

<<code language="ocaml"|
let rec tic () =
    print_endline "tic";
    let%lwt () = Lwt_unix.sleep 1.0 in
    tic ()
>>

Replace {{{Lwt_unix.sleep}}} by {{{Lwt_js.sleep}}} if your program is
running in a browser.


=== Launching concurrent threads and waiting for their results

Suppose you have two cooperative functions:
<<code language="ocaml"|
val f : unit -> unit Lwt.t
val g : unit -> unit Lwt.t
>>

The following code runs {{{f ()}}} and {{{g ()}}} sequentially:
<<code language="ocaml"|
let%lwt () = f () in
let%lwt () = g () in
...
>>

The following code launches both {{{f ()}}} and {{{g ()}}} concurrently,
then waits for both to terminate before continuing:
<<code language="ocaml"|
let p1 = f () in
let p2 = g () in
let%lwt () = p1 in
let%lwt () = p2 in
...
>>

To detach a thread, it is recommended to use
<<code language="ocaml"|
Lwt.async (fun () -> f ())
>>
instead of
<<code language="ocaml"|
ignore (f ())
>>
to catch exceptions properly.

=== Serial and concurrent map on lists

The following map function runs all computation concurrently
on all list elements:
<<code language="ocaml"|
let rec map f l =
  match l with
  | [] -> Lwt.return []
  | v :: r ->
      let t = f v in
      let rt = map f r in
      let%lwt v' = t in
      let%lwt l' = rt in
      Lwt.return (v' :: l')
>>

whereas the following one waits for the one to complete before
launching the next one:
<<code language="ocaml"|
let rec map_serial f l =
  match l with
  | [] -> return []
  | v :: r ->
      let%lwt v' = f v in
      let%lwt l' = map_serial f r in
      Lwt.return (v' :: l')
>>


== More documentation

Have a look at <<a_manual project="lwt" chapter="manual"|Lwt's manual>>
for more details about Lwt.
You will learn how to handle exception (using {{{Lwt.fail}}}
and {{{Lwt.catch}}} or {{{try%lwt}}}).
You will also learn for example how to create a thread that waits until it is
awoken (using {{{Lwt.wait}}} and {{{Lwt.wakeup}}}).
