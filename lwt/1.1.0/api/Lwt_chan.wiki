=Module <<a_api_type | module Lwt_chan >> =
<<div class="code"|<<span class="keyword"|module>> Lwt_chan: <<span class='code'|sig>><<a_api text=".." | module Lwt_chan >><<span class='code'|end>>>>~Module <<span class='code'|~Lwt~_chan>>~: cooperative~, <<span class='code'|~Pervasives>>~-like~, ~I~/~O functions\\

----
\\
~Note~: the <<a_api | module Lwt_io >> module deprecates this module~.\\
<<div class="code" id="TYPEin_channel"|<<span class="keyword"|type>> in~_channel = <<span class="code type"|<<a_api text="Lwt_io.input_channel" | type Lwt_io.input_channel >>>> >>
<<div class="info"|
==@@id="2_Cooperativeinputchannels"@@~Cooperative input channels==
\\
>>

<<div id="VALin_channel_of_descr" class="code"|<<span class="keyword"|val>> in~_channel~_of~_descr : <<span class="code type"|<<a_api text="Lwt_unix.file_descr" | type Lwt_unix.file_descr >> -> <<a_api text="in_channel" | type Lwt_chan.in_channel >>>>>><<div id="VALmake_in_channel" class="code"|<<span class="keyword"|val>> make~_in~_channel : <<span class="code type"|\\{{{   }}}?close:(unit -> unit <<a_api text="Lwt.t" | type Lwt.t >>) ->\\{{{   }}}  (string -> int -> int -> int <<a_api text="Lwt.t" | type Lwt.t >>) -> <<a_api text="in_channel" | type Lwt_chan.in_channel >>>>>><<div class="info"|<<span class='code'|make~_in~_channel read>> creates an input channel from the <<span class='code'|read>>
    function~. <<span class='code'|read s ofs len>> should ~(cooperatively~) read <<span class='code'|len>> bytes from
    the source~, and put them in <<span class='code'|s>>~, at offset <<span class='code'|ofs>>~, and return the number
    of bytes effectively read~. ~If provided~, <<span class='code'|close>> will be called by
    <<span class='code'|close~_in>>~. ~By default~, <<span class='code'|close~_in>> does not do anything~.\\
>>
<<div id="VALinput_line" class="code"|<<span class="keyword"|val>> input~_line : <<span class="code type"|<<a_api text="in_channel" | type Lwt_chan.in_channel >> -> string <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALinput_value" class="code"|<<span class="keyword"|val>> input~_value : <<span class="code type"|<<a_api text="in_channel" | type Lwt_chan.in_channel >> -> 'a <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALinput" class="code"|<<span class="keyword"|val>> input : <<span class="code type"|<<a_api text="in_channel" | type Lwt_chan.in_channel >> -> string -> int -> int -> int <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALreally_input" class="code"|<<span class="keyword"|val>> really~_input : <<span class="code type"|<<a_api text="in_channel" | type Lwt_chan.in_channel >> -> string -> int -> int -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALinput_char" class="code"|<<span class="keyword"|val>> input~_char : <<span class="code type"|<<a_api text="in_channel" | type Lwt_chan.in_channel >> -> char <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALinput_binary_int" class="code"|<<span class="keyword"|val>> input~_binary~_int : <<span class="code type"|<<a_api text="in_channel" | type Lwt_chan.in_channel >> -> int <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALopen_in_gen" class="code"|<<span class="keyword"|val>> open~_in~_gen : <<span class="code type"|Unix.open_flag list -> int -> string -> <<a_api text="in_channel" | type Lwt_chan.in_channel >> <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALopen_in" class="code"|<<span class="keyword"|val>> open~_in : <<span class="code type"|string -> <<a_api text="in_channel" | type Lwt_chan.in_channel >> <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALclose_in" class="code"|<<span class="keyword"|val>> close~_in : <<span class="code type"|<<a_api text="in_channel" | type Lwt_chan.in_channel >> -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>>\\

==@@id="2_Cooperativeoutputchannels"@@~Cooperative output channels==
\\
<<div class="code" id="TYPEout_channel"|<<span class="keyword"|type>> out~_channel = <<span class="code type"|<<a_api text="Lwt_io.output_channel" | type Lwt_io.output_channel >>>> >>

<<div id="VALout_channel_of_descr" class="code"|<<span class="keyword"|val>> out~_channel~_of~_descr : <<span class="code type"|<<a_api text="Lwt_unix.file_descr" | type Lwt_unix.file_descr >> -> <<a_api text="out_channel" | type Lwt_chan.out_channel >>>>>><<div id="VALmake_out_channel" class="code"|<<span class="keyword"|val>> make~_out~_channel : <<span class="code type"|\\{{{   }}}?close:(unit -> unit <<a_api text="Lwt.t" | type Lwt.t >>) ->\\{{{   }}}  (string -> int -> int -> int <<a_api text="Lwt.t" | type Lwt.t >>) -> <<a_api text="out_channel" | type Lwt_chan.out_channel >>>>>><<div class="info"|<<span class='code'|make~_out~_channel write>> creates an output channel from the <<span class='code'|write>>
    function~. <<span class='code'|write s ofs len>> should ~(cooperatively~) write <<span class='code'|len>> bytes from
    <<span class='code'|s>>~, starting at offset <<span class='code'|ofs>>~, to the backend~, and return the number of
    bytes effectively written~. ~If provided~, <<span class='code'|close>> will be called by
    <<span class='code'|close~_out>>~. ~By default~, <<span class='code'|close~_out>> does not do anything~.\\
>>
<<div id="VALoutput" class="code"|<<span class="keyword"|val>> output : <<span class="code type"|<<a_api text="out_channel" | type Lwt_chan.out_channel >> -> string -> int -> int -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALflush" class="code"|<<span class="keyword"|val>> flush : <<span class="code type"|<<a_api text="out_channel" | type Lwt_chan.out_channel >> -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALoutput_string" class="code"|<<span class="keyword"|val>> output~_string : <<span class="code type"|<<a_api text="out_channel" | type Lwt_chan.out_channel >> -> string -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALoutput_value" class="code"|<<span class="keyword"|val>> output~_value : <<span class="code type"|<<a_api text="out_channel" | type Lwt_chan.out_channel >> -> 'a -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALoutput_char" class="code"|<<span class="keyword"|val>> output~_char : <<span class="code type"|<<a_api text="out_channel" | type Lwt_chan.out_channel >> -> char -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALoutput_binary_int" class="code"|<<span class="keyword"|val>> output~_binary~_int : <<span class="code type"|<<a_api text="out_channel" | type Lwt_chan.out_channel >> -> int -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALopen_out_gen" class="code"|<<span class="keyword"|val>> open~_out~_gen : <<span class="code type"|Unix.open_flag list -> int -> string -> <<a_api text="out_channel" | type Lwt_chan.out_channel >> <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALopen_out" class="code"|<<span class="keyword"|val>> open~_out : <<span class="code type"|string -> <<a_api text="out_channel" | type Lwt_chan.out_channel >> <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALclose_out" class="code"|<<span class="keyword"|val>> close~_out : <<span class="code type"|<<a_api text="out_channel" | type Lwt_chan.out_channel >> -> unit <<a_api text="Lwt.t" | type Lwt.t >>>>>><<div id="VALopen_connection" class="code"|<<span class="keyword"|val>> open~_connection : <<span class="code type"|Unix.sockaddr -> (<<a_api text="in_channel" | type Lwt_chan.in_channel >> * <<a_api text="out_channel" | type Lwt_chan.out_channel >>) <<a_api text="Lwt.t" | type Lwt.t >>>>>>