<<code language="ocaml" | sig
  exception Eliom_Internal_Error of string
  external id : 'a -> 'a = "%identity"
  val ( >>= ) : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t
  val ( >|= ) : 'a Lwt.t -> ('a -> 'b) -> 'b Lwt.t
  val ( !! ) : 'a Lazy.t -> 'a
  type yesnomaybe = Yes | No | Maybe
  type ('a, 'b) leftright = Left of 'a | Right of 'b
  val map_option : ('a -> 'b) -> 'a option -> 'b option
  val fst3 : 'a * 'b * 'c -> 'a
  val snd3 : 'a * 'b * 'c -> 'b
  val thd3 : 'a * 'b * 'c -> 'c
  module List :
    sig
      val length : 'a list -> int
      val hd : 'a list -> 'a
      val tl : 'a list -> 'a list
      val nth : 'a list -> int -> 'a
      val rev : 'a list -> 'a list
      val append : 'a list -> 'a list -> 'a list
      val rev_append : 'a list -> 'a list -> 'a list
      val concat : 'a list list -> 'a list
      val flatten : 'a list list -> 'a list
      val iter : ('a -> unit) -> 'a list -> unit
      val map : ('a -> 'b) -> 'a list -> 'b list
      val rev_map : ('a -> 'b) -> 'a list -> 'b list
      val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
      val fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
      val iter2 : ('a -> 'b -> unit) -> 'a list -> 'b list -> unit
      val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
      val rev_map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
      val fold_left2 :
        ('a -> 'b -> 'c -> 'a) -> 'a -> 'b list -> 'c list -> 'a
      val fold_right2 :
        ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
      val for_all : ('a -> bool) -> 'a list -> bool
      val exists : ('a -> bool) -> 'a list -> bool
      val for_all2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
      val exists2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
      val mem : 'a -> 'a list -> bool
      val memq : 'a -> 'a list -> bool
      val find : ('a -> bool) -> 'a list -> 'a
      val filter : ('a -> bool) -> 'a list -> 'a list
      val find_all : ('a -> bool) -> 'a list -> 'a list
      val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
      val assoc : 'a -> ('a * 'b) list -> 'b
      val assq : 'a -> ('a * 'b) list -> 'b
      val mem_assoc : 'a -> ('a * 'b) list -> bool
      val mem_assq : 'a -> ('a * 'b) list -> bool
      val remove_assoc : 'a -> ('a * 'b) list -> ('a * 'b) list
      val remove_assq : 'a -> ('a * 'b) list -> ('a * 'b) list
      val split : ('a * 'b) list -> 'a list * 'b list
      val combine : 'a list -> 'b list -> ('a * 'b) list
      val sort : ('a -> 'a -> int) -> 'a list -> 'a list
      val stable_sort : ('a -> 'a -> int) -> 'a list -> 'a list
      val fast_sort : ('a -> 'a -> int) -> 'a list -> 'a list
      val merge : ('a -> 'a -> int) -> 'a list -> 'a list -> 'a list
      val assoc_remove : 'a -> ('a * 'b) list -> 'b * ('a * 'b) list
      val remove_all_assoc : 'a -> ('a * 'b) list -> ('a * 'b) list
      val remove_first_if_any : 'a -> 'a list -> 'a list
      val remove_first_if_any_q : 'a -> 'a list -> 'a list
    end
  module String :
    sig
      external length : string -> int = "%string_length"
      external get : string -> int -> char = "%string_safe_get"
      external set : string -> int -> char -> unit = "%string_safe_set"
      external create : int -> string = "caml_create_string"
      val make : int -> char -> string
      val copy : string -> string
      val sub : string -> int -> int -> string
      val fill : string -> int -> int -> char -> unit
      val blit : string -> int -> string -> int -> int -> unit
      val concat : string -> string list -> string
      val iter : (char -> unit) -> string -> unit
      val escaped : string -> string
      val index : string -> char -> int
      val rindex : string -> char -> int
      val index_from : string -> int -> char -> int
      val rindex_from : string -> int -> char -> int
      val contains : string -> char -> bool
      val contains_from : string -> int -> char -> bool
      val rcontains_from : string -> int -> char -> bool
      val uppercase : string -> string
      val lowercase : string -> string
      val capitalize : string -> string
      val uncapitalize : string -> string
      type t = string
      val compare : t -> t -> int
      external unsafe_get : string -> int -> char = "%string_unsafe_get"
      external unsafe_set : string -> int -> char -> unit
        = "%string_unsafe_set"
      external unsafe_blit : string -> int -> string -> int -> int -> unit
        = "caml_blit_string" "noalloc"
      external unsafe_fill : string -> int -> int -> char -> unit
        = "caml_fill_string" "noalloc"
      val basic_sep : char -> string -> string * string
      val sep : char -> string -> string * string
      val split : ?multisep:bool -> char -> string -> string list
      val first_diff : string -> string -> int -> int -> int
      val may_append : string -> sep:string -> string -> string
      val may_concat : string -> sep:string -> string -> string
      val make_cryptographic_safe : unit -> string
      module Table :
        sig
          type key = string
          type 'a t = 'a Ocsigen_pervasives.String.Table.t
          val empty : 'a t
          val is_empty : 'a t -> bool
          val mem : key -> 'a t -> bool
          val add : key -> 'a -> 'a t -> 'a t
          val singleton : key -> 'a -> 'a t
          val remove : key -> 'a t -> 'a t
          val merge :
            (key -> 'a option -> 'b option -> 'c option) ->
            'a t -> 'b t -> 'c t
          val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
          val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
          val iter : (key -> 'a -> unit) -> 'a t -> unit
          val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
          val for_all : (key -> 'a -> bool) -> 'a t -> bool
          val exists : (key -> 'a -> bool) -> 'a t -> bool
          val filter : (key -> 'a -> bool) -> 'a t -> 'a t
          val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
          val cardinal : 'a t -> int
          val bindings : 'a t -> (key * 'a) list
          val min_binding : 'a t -> key * 'a
          val max_binding : 'a t -> key * 'a
          val choose : 'a t -> key * 'a
          val split : key -> 'a t -> 'a t * 'a option * 'a t
          val find : key -> 'a t -> 'a
          val map : ('a -> 'b) -> 'a t -> 'b t
          val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
        end
    end
  module Url :
    sig
      type t = Ocsigen_pervasives.Url.t
      type uri = Ocsigen_pervasives.Url.uri
      type path = Ocsigen_pervasives.Url.path
      val make_absolute_url :
        https:bool ->
        host:string ->
        port:int -> Eliom_pervasives.Url.uri -> Eliom_pervasives.Url.t
      val remove_slash_at_beginning :
        Eliom_pervasives.Url.path -> Eliom_pervasives.Url.path
      val remove_internal_slash :
        Eliom_pervasives.Url.path -> Eliom_pervasives.Url.path
      val is_prefix_skip_end_slash : string list -> string list -> bool
      val change_empty_list :
        Eliom_pervasives.Url.path -> Eliom_pervasives.Url.path
      val string_of_url_path :
        encode:bool -> Eliom_pervasives.Url.path -> Eliom_pervasives.Url.uri
      val make_encoded_parameters :
        (string * string) list -> Eliom_pervasives.Url.uri
      val encode : ?plus:bool -> string -> string
      val decode : ?plus:bool -> string -> string
    end
  module Ip_address :
    sig
      type t =
        Ocsigen_pervasives.Ip_address.t =
          IPv4 of int32
        | IPv6 of int64 * int64
      val parse :
        string ->
        Eliom_pervasives.Ip_address.t * Eliom_pervasives.Ip_address.t option
      val network_of_ip :
        Eliom_pervasives.Ip_address.t ->
        int32 -> int64 * int64 -> Eliom_pervasives.Ip_address.t
      val inet6_addr_loopback : Eliom_pervasives.Ip_address.t
    end
  module Filename :
    sig
      val current_dir_name : string
      val parent_dir_name : string
      val dir_sep : string
      val concat : string -> string -> string
      val is_relative : string -> bool
      val is_implicit : string -> bool
      val check_suffix : string -> string -> bool
      val chop_suffix : string -> string -> string
      val chop_extension : string -> string
      val basename : string -> string
      val dirname : string -> string
      val temp_file : ?temp_dir:string -> string -> string -> string
      val open_temp_file :
        ?mode:open_flag list ->
        ?temp_dir:string -> string -> string -> string * out_channel
      val temp_dir_name : string
      val quote : string -> string
    end
  module Printexc :
    sig
      val to_string : exn -> string
      val print : ('a -> 'b) -> 'a -> 'b
      val catch : ('a -> 'b) -> 'a -> 'b
      val print_backtrace : out_channel -> unit
      val get_backtrace : unit -> string
      val record_backtrace : bool -> unit
      val backtrace_status : unit -> bool
      val register_printer : (exn -> string option) -> unit
    end
  module Int :
    sig
      module Table :
        sig
          type key = int
          type +'a t
          val empty : 'a t
          val is_empty : 'a t -> bool
          val mem : key -> 'a t -> bool
          val add : key -> 'a -> 'a t -> 'a t
          val singleton : key -> 'a -> 'a t
          val remove : key -> 'a t -> 'a t
          val merge :
            (key -> 'a option -> 'b option -> 'c option) ->
            'a t -> 'b t -> 'c t
          val compare : ('a -> 'a -> int) -> 'a t -> 'a t -> int
          val equal : ('a -> 'a -> bool) -> 'a t -> 'a t -> bool
          val iter : (key -> 'a -> unit) -> 'a t -> unit
          val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
          val for_all : (key -> 'a -> bool) -> 'a t -> bool
          val exists : (key -> 'a -> bool) -> 'a t -> bool
          val filter : (key -> 'a -> bool) -> 'a t -> 'a t
          val partition : (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
          val cardinal : 'a t -> int
          val bindings : 'a t -> (key * 'a) list
          val min_binding : 'a t -> key * 'a
          val max_binding : 'a t -> key * 'a
          val choose : 'a t -> key * 'a
          val split : key -> 'a t -> 'a t * 'a option * 'a t
          val find : key -> 'a t -> 'a
          val map : ('a -> 'b) -> 'a t -> 'b t
          val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
        end
    end
  val to_json : ?typ:'a Deriving_Json.t -> 'a -> string
  val of_json : ?typ:'a Deriving_Json.t -> string -> 'a
  module XML :
    sig
      module M :
        sig
          type aname = string
          type separator = Space | Comma
          type event = string
          type attrib
          type acontent = private
              AFloat of Eliom_pervasives.XML.M.aname * float
            | AInt of Eliom_pervasives.XML.M.aname * int
            | AStr of Eliom_pervasives.XML.M.aname * string
            | AStrL of Eliom_pervasives.XML.M.separator *
                Eliom_pervasives.XML.M.aname * string list
          val acontent :
            Eliom_pervasives.XML.M.attrib -> Eliom_pervasives.XML.M.acontent
          val aname :
            Eliom_pervasives.XML.M.attrib -> Eliom_pervasives.XML.M.aname
          val float_attrib :
            Eliom_pervasives.XML.M.aname ->
            float -> Eliom_pervasives.XML.M.attrib
          val int_attrib :
            Eliom_pervasives.XML.M.aname ->
            int -> Eliom_pervasives.XML.M.attrib
          val string_attrib :
            Eliom_pervasives.XML.M.aname ->
            string -> Eliom_pervasives.XML.M.attrib
          val space_sep_attrib :
            Eliom_pervasives.XML.M.aname ->
            string list -> Eliom_pervasives.XML.M.attrib
          val comma_sep_attrib :
            Eliom_pervasives.XML.M.aname ->
            string list -> Eliom_pervasives.XML.M.attrib
          val event_attrib :
            Eliom_pervasives.XML.M.aname ->
            Eliom_pervasives.XML.M.event -> Eliom_pervasives.XML.M.attrib
          val attrib_name :
            Eliom_pervasives.XML.M.attrib -> Eliom_pervasives.XML.M.aname
          val attrib_value_to_string :
            (string -> string) -> Eliom_pervasives.XML.M.attrib -> string
          val attrib_to_string :
            (string -> string) -> Eliom_pervasives.XML.M.attrib -> string
          type ename = string
          type econtent =
              Empty
            | Comment of string
            | EncodedPCDATA of string
            | PCDATA of string
            | Entity of string
            | Leaf of Eliom_pervasives.XML.M.ename *
                Eliom_pervasives.XML.M.attrib list
            | Node of Eliom_pervasives.XML.M.ename *
                Eliom_pervasives.XML.M.attrib list *
                Eliom_pervasives.XML.M.elt list
          and elt = {
            mutable ref : int;
            elt : Eliom_pervasives.XML.M.econtent;
            elt_mark : Obj.t;
          }
          val content :
            Eliom_pervasives.XML.M.elt -> Eliom_pervasives.XML.M.econtent
          val make_mark : (unit -> Obj.t) Pervasives.ref
          val make_node :
            Eliom_pervasives.XML.M.econtent -> Eliom_pervasives.XML.M.elt
          val empty : unit -> Eliom_pervasives.XML.M.elt
          val comment : string -> Eliom_pervasives.XML.M.elt
          val pcdata : string -> Eliom_pervasives.XML.M.elt
          val encodedpcdata : string -> Eliom_pervasives.XML.M.elt
          val entity : string -> Eliom_pervasives.XML.M.elt
          val leaf :
            ?a:Eliom_pervasives.XML.M.attrib list ->
            Eliom_pervasives.XML.M.ename -> Eliom_pervasives.XML.M.elt
          val node :
            ?a:Eliom_pervasives.XML.M.attrib list ->
            Eliom_pervasives.XML.M.ename ->
            Eliom_pervasives.XML.M.elt list -> Eliom_pervasives.XML.M.elt
          val cdata : string -> Eliom_pervasives.XML.M.elt
          val cdata_script : string -> Eliom_pervasives.XML.M.elt
          val cdata_style : string -> Eliom_pervasives.XML.M.elt
          type ref_tree =
              Ref_tree of int option *
                (int * Eliom_pervasives.XML.M.ref_tree) list
          val ref_node : Eliom_pervasives.XML.M.elt -> int
          val next_ref : unit -> int
          val make_ref_tree :
            Eliom_pervasives.XML.M.elt -> Eliom_pervasives.XML.M.ref_tree
          val make_ref_tree_list :
            Eliom_pervasives.XML.M.elt list ->
            (int * Eliom_pervasives.XML.M.ref_tree) list
          val class_name : string
          val lwt_register_event :
            ?keep_default:bool ->
            Eliom_pervasives.XML.M.elt ->
            Eliom_pervasives.XML.M.ename -> ('a -> 'b Lwt.t) -> 'a -> unit
          val register_event :
            ?keep_default:bool ->
            Eliom_pervasives.XML.M.elt ->
            Eliom_pervasives.XML.M.ename -> ('a -> 'b) -> 'a -> unit
        end
    end
  module SVG :
    sig
      module M : SVG_sigs.SVG(XML.M).T
      module P : XML_sigs.TypedSimplePrinter(XML.M)(M).T
    end
  module HTML5 :
    sig
      module M : HTML5_sigs.HTML5(XML.M)(SVG.M).T
      module P : XML_sigs.TypedSimplePrinter(XML.M)(M).T
    end
  module XHTML :
    sig
      module M : XHTML_sigs.XHTML(XML.M).T
      module M_01_01 : XHTML_sigs.XHTML(XML.M).T
      module M_01_00 : XHTML_sigs.XHTML(XML.M).T
      module P : XML_sigs.TypedSimplePrinter(XML.M)(M).T
    end
end >>