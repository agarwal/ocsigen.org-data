<<code language="ocaml" | sig
  module S :
    sig
      type 'a t = 'a React.signal
      val const : 'a -> 'a React.signal
      val value : 'a React.signal -> 'a
      val retain :
        'a React.signal -> (unit -> unit) -> [ `R of unit -> unit ]
      val eq_fun : 'a React.signal -> ('a -> 'a -> bool) option
      val stop : ?strong:bool -> 'a React.signal -> unit
      val equal :
        ?eq:('a -> 'a -> bool) -> 'a React.signal -> 'a React.signal -> bool
      val trace :
        ?iff:bool t -> ('a -> unit) -> 'a React.signal -> 'a React.signal
      val hold :
        ?eq:('a -> 'a -> bool) -> 'a -> 'a React.event -> 'a React.signal
      val app :
        ?eq:('b -> 'b -> bool) ->
        ('a -> 'b) React.signal -> 'a React.signal -> 'b React.signal
      val map :
        ?eq:('b -> 'b -> bool) ->
        ('a -> 'b) -> 'a React.signal -> 'b React.signal
      val filter :
        ?eq:('a -> 'a -> bool) ->
        ('a -> bool) -> 'a -> 'a React.signal -> 'a React.signal
      val fmap :
        ?eq:('b -> 'b -> bool) ->
        ('a -> 'b option) -> 'b -> 'a React.signal -> 'b React.signal
      val diff : ('a -> 'a -> 'b) -> 'a React.signal -> 'b React.event
      val changes : 'a React.signal -> 'a React.event
      val sample :
        ('b -> 'a -> 'c) ->
        'b React.event -> 'a React.signal -> 'c React.event
      val on :
        ?eq:('a -> 'a -> bool) ->
        bool React.signal -> 'a -> 'a React.signal -> 'a React.signal
      val when_ :
        ?eq:('a -> 'a -> bool) ->
        bool React.signal -> 'a -> 'a React.signal -> 'a React.signal
      val dismiss :
        ?eq:('a -> 'a -> bool) ->
        'b React.event -> 'a -> 'a React.signal -> 'a React.signal
      val accum :
        ?eq:('a -> 'a -> bool) ->
        ('a -> 'a) React.event -> 'a -> 'a React.signal
      val fold :
        ?eq:('a -> 'a -> bool) ->
        ('a -> 'b -> 'a) -> 'a -> 'b React.event -> 'a React.signal
      val merge :
        ?eq:('a -> 'a -> bool) ->
        ('a -> 'b -> 'a) -> 'a -> 'b React.signal list -> 'a React.signal
      val switch :
        ?eq:('a -> 'a -> bool) ->
        'a React.signal React.signal -> 'a React.signal
      val bind :
        ?eq:('b -> 'b -> bool) ->
        'a React.signal -> ('a -> 'b React.signal) -> 'b React.signal
      val fix :
        ?eq:('a -> 'a -> bool) ->
        'a -> ('a React.signal -> 'a React.signal * 'b) -> 'b
      val l1 :
        ?eq:('b -> 'b -> bool) ->
        ('a -> 'b) -> 'a React.signal -> 'b React.signal
      val l2 :
        ?eq:('c -> 'c -> bool) ->
        ('a -> 'b -> 'c) ->
        'a React.signal -> 'b React.signal -> 'c React.signal
      val l3 :
        ?eq:('d -> 'd -> bool) ->
        ('a -> 'b -> 'c -> 'd) ->
        'a React.signal ->
        'b React.signal -> 'c React.signal -> 'd React.signal
      val l4 :
        ?eq:('e -> 'e -> bool) ->
        ('a -> 'b -> 'c -> 'd -> 'e) ->
        'a React.signal ->
        'b React.signal ->
        'c React.signal -> 'd React.signal -> 'e React.signal
      val l5 :
        ?eq:('f -> 'f -> bool) ->
        ('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->
        'a React.signal ->
        'b React.signal ->
        'c React.signal ->
        'd React.signal -> 'e React.signal -> 'f React.signal
      val l6 :
        ?eq:('g -> 'g -> bool) ->
        ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g) ->
        'a React.signal ->
        'b React.signal ->
        'c React.signal ->
        'd React.signal ->
        'e React.signal -> 'f React.signal -> 'g React.signal
      module Bool = React.S.Bool
      module Int = React.S.Int
      module Float = React.S.Float
      module Pair = React.S.Pair
      module Option = React.S.Option
      module Compare = React.S.Compare
      module type EqType = sig type 'a t val equal : 'a t -> 'a t -> bool end
      module type S =
        sig
          type 'a v
          val create :
            'a v -> 'a v React.signal * (?step:React.step -> 'a v -> unit)
          val equal : 'a v React.signal -> 'a v React.signal -> bool
          val hold : 'a v -> 'a v React.event -> 'a v React.signal
          val app :
            ('a -> 'b v) React.signal -> 'a React.signal -> 'b v React.signal
          val map : ('a -> 'b v) -> 'a React.signal -> 'b v React.signal
          val filter :
            ('a v -> bool) -> 'a v -> 'a v React.signal -> 'a v React.signal
          val fmap :
            ('a -> 'b v option) ->
            'b v -> 'a React.signal -> 'b v React.signal
          val when_ :
            bool React.signal ->
            'a v -> 'a v React.signal -> 'a v React.signal
          val dismiss :
            'b React.event -> 'a v -> 'a v React.signal -> 'a v React.signal
          val accum : ('a v -> 'a v) React.event -> 'a v -> 'a v React.signal
          val fold :
            ('a v -> 'b -> 'a v) ->
            'a v -> 'b React.event -> 'a v React.signal
          val merge :
            ('a v -> 'b -> 'a v) ->
            'a v -> 'b React.signal list -> 'a v React.signal
          val switch : 'a v React.signal React.signal -> 'a v React.signal
          val bind :
            'b React.signal -> ('b -> 'a v React.signal) -> 'a v React.signal
          val fix :
            'a v -> ('a v React.signal -> 'a v React.signal * 'b) -> 'b
          val l1 : ('a -> 'b v) -> 'a React.signal -> 'b v React.signal
          val l2 :
            ('a -> 'b -> 'c v) ->
            'a React.signal -> 'b React.signal -> 'c v React.signal
          val l3 :
            ('a -> 'b -> 'c -> 'd v) ->
            'a React.signal ->
            'b React.signal -> 'c React.signal -> 'd v React.signal
          val l4 :
            ('a -> 'b -> 'c -> 'd -> 'e v) ->
            'a React.signal ->
            'b React.signal ->
            'c React.signal -> 'd React.signal -> 'e v React.signal
          val l5 :
            ('a -> 'b -> 'c -> 'd -> 'e -> 'f v) ->
            'a React.signal ->
            'b React.signal ->
            'c React.signal ->
            'd React.signal -> 'e React.signal -> 'f v React.signal
          val l6 :
            ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g v) ->
            'a React.signal ->
            'b React.signal ->
            'c React.signal ->
            'd React.signal ->
            'e React.signal -> 'f React.signal -> 'g v React.signal
        end
      module Make = React.S.Make
      module Special = React.S.Special
      module Lwt = React.S.Lwt
      val create :
        ?eq:('a -> 'a -> bool) ->
        ?default:('a Eliom_csreact.React.signal *
                  (?step:Eliom_csreact.React.step -> 'a -> unit))
                 option ->
        ?reset_default:bool ->
        'a ->
        'a Eliom_csreact.React.signal *
        (?step:Eliom_csreact.React.step -> 'a -> unit)
    end
  type 'a t = 'a React.event
  val never : 'a React.event
  val create : unit -> 'a React.event * (?step:React.step -> 'a -> unit)
  val retain : 'a React.event -> (unit -> unit) -> [ `R of unit -> unit ]
  val stop : ?strong:bool -> 'a React.event -> unit
  val equal : 'a React.event -> 'a React.event -> bool
  val trace :
    ?iff:bool React.signal ->
    ('a -> unit) -> 'a React.event -> 'a React.event
  val once : 'a React.event -> 'a React.event
  val drop_once : 'a React.event -> 'a React.event
  val app : ('a -> 'b) React.event -> 'a React.event -> 'b React.event
  val map : ('a -> 'b) -> 'a React.event -> 'b React.event
  val stamp : 'b React.event -> 'a -> 'a React.event
  val filter : ('a -> bool) -> 'a React.event -> 'a React.event
  val fmap : ('a -> 'b option) -> 'a React.event -> 'b React.event
  val diff : ('a -> 'a -> 'b) -> 'a React.event -> 'b React.event
  val changes : ?eq:('a -> 'a -> bool) -> 'a React.event -> 'a React.event
  val on : bool React.signal -> 'a React.event -> 'a React.event
  val when_ : bool React.signal -> 'a React.event -> 'a React.event
  val dismiss : 'b React.event -> 'a React.event -> 'a React.event
  val until : 'a React.event -> 'b React.event -> 'b React.event
  val accum : ('a -> 'a) React.event -> 'a -> 'a React.event
  val fold : ('a -> 'b -> 'a) -> 'a -> 'b React.event -> 'a React.event
  val select : 'a React.event list -> 'a React.event
  val merge : ('a -> 'b -> 'a) -> 'a -> 'b React.event list -> 'a React.event
  val switch : 'a React.event -> 'a React.event React.event -> 'a React.event
  val fix : ('a React.event -> 'a React.event * 'b) -> 'b
  val l1 : ('a -> 'b) -> 'a React.event -> 'b React.event
  val l2 :
    ('a -> 'b -> 'c) -> 'a React.event -> 'b React.event -> 'c React.event
  val l3 :
    ('a -> 'b -> 'c -> 'd) ->
    'a React.event -> 'b React.event -> 'c React.event -> 'd React.event
  val l4 :
    ('a -> 'b -> 'c -> 'd -> 'e) ->
    'a React.event ->
    'b React.event -> 'c React.event -> 'd React.event -> 'e React.event
  val l5 :
    ('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->
    'a React.event ->
    'b React.event ->
    'c React.event -> 'd React.event -> 'e React.event -> 'f React.event
  val l6 :
    ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g) ->
    'a React.event ->
    'b React.event ->
    'c React.event ->
    'd React.event -> 'e React.event -> 'f React.event -> 'g React.event
  module Option :
    sig
      val some : 'a React.event -> 'a option React.event
      val value :
        ?default:'a React.signal -> 'a option React.event -> 'a React.event
    end
end >>