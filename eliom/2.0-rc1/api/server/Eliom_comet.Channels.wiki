=Module <<a_api_type subproject="server" | module Eliom_comet.Channels >> =
<<div class="code"|<<span class="keyword"|module>> Channels: <<span class='code'|sig>><<a_api subproject="server" text=".." | module Eliom_comet.Channels >><<span class='code'|end>>>>
----
<<div class="code" id="TYPEt"|<<span class="keyword"|type>> <<span class="code type"|'a>> t>>

<<div class="code" id="TYPEcomet_scope"|<<span class="keyword"|type>> comet~_scope = <<span class="code type"|[ `Client_process of <<a_api subproject="server" text="Eliom_common.scope_name" | type Eliom_common.scope_name >> | `Global ]>> >>
<<div class="info"|<<span class='code'|v t>> is the type of server~-to~-client communication channels
      transporting data of type <<span class='code'|v>>\\
>>

<<div id="VALcreate" class="code"|<<span class="keyword"|val>> create : <<span class="code type"|\\{{{   }}}?scope:[< <<a_api subproject="server" text="comet_scope" | type Eliom_comet.Channels.comet_scope >> ] ->\\{{{   }}}  ?name:string -> ?size:int -> 'a Lwt_stream.t -> 'a <<a_api subproject="server" text="t" | type Eliom_comet.Channels.t >>>>>><<div id="VALcreate_unlimited" class="code"|<<span class="keyword"|val>> create~_unlimited : <<span class="code type"|\\{{{   }}}?scope:<<a_api subproject="server" text="Eliom_common.client_process_scope" | type Eliom_common.client_process_scope >> ->\\{{{   }}}  ?name:string -> 'a Lwt_stream.t -> 'a <<a_api subproject="server" text="t" | type Eliom_comet.Channels.t >>>>>><<div class="info"|<<span class='code'|create s>> returns a channel sending values from <<span class='code'|s>>~.\\


      ~There are two kind of channels created depending on the given
      scope ~( defaults to <<span class='code'|~Eliom~_common~.comet~_client~_process>> ~)~.\\


      ~With scope <<span class='code'|`~Global>> all user knowing the name of the channel
      can access it~. ~Only one message queue is created~: it is what we
      call a stateless channel in the sense that the memory used by
      the channel doesn~'t depend on the number of users~.
      ~Warning~: as of now~, global channels can~'t be reclaimed by the ~G~C~,
      you should only create a bounded number~.
      ~The buffer channel has a limited buffer of size <<span class='code'|size>> ~(default~: ~1~0~0~0~)~.
      ~If the client request too old messages~, it raise ~( on client side ~)
      ~Channel~_full~.\\


      ~With scope <<span class='code'|`~Client~_process ~_>> the channel can only be accessed
      by the user which created it~. ~It can only be created when client
      application datas are available~. ~The eliom service created to
      communicate with the client is only available in the scope of
      the client process~. ~To avoid memory leak when the client do not
      read the sent datas~, the channel has a limited <<span class='code'|size>>~. ~When a
      channel is full~, no data can be read from it anymore~.\\


      ~A channel can be used only one time on client side~. ~To be able
      to receive the same data multiples times on client side~, use
      <<span class='code'|create ~(~Lwt~_stream~.clone s~)>> each time~.\\


      ~To enforce the limit on the buffer size~, the data are read into
      <<span class='code'|stream>> as soon as possible~: ~If you want a channel that read
      data to the stream only when the client request it~, use
      <<span class='code'|create~_unlimited>> instead~, but be carefull to memory leaks~.\\
>>
<<div id="VALcreate_newest" class="code"|<<span class="keyword"|val>> create~_newest : <<span class="code type"|?name:string -> 'a Lwt_stream.t -> 'a <<a_api subproject="server" text="t" | type Eliom_comet.Channels.t >>>>>><<div class="info"|<<span class='code'|create~_unlimited s>> creates a channel wich does not read
      immediately on the stream it is read only when the client
      request it~: use it if the data you send depends on the time of
      the request ~( for instance the number of unread mails ~)~. ~Be
      carefull the size of this stream is not limited~: if the size of
      the stream increase and your clients don~'t read it~, you may have
      memory leaks~.\\
>>
\\
<<span class='code'|create~_newest s>> is similar to <<span class='code'|create ~~scope~:`~Global s>> but
      only the last message is returned to the client~.\\
