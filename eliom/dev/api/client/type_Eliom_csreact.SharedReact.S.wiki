<<code language="ocaml" | sig
  type 'a t = 'a React.signal
  val const : 'a -> 'a React.signal
  val value : 'a React.signal -> 'a
  val retain : 'a React.signal -> (unit -> unit) -> [ `R of unit -> unit ]
  val eq_fun : 'a React.signal -> ('a -> 'a -> bool) option
  val stop : ?strong:bool -> 'a React.signal -> unit
  val equal :
    ?eq:('a -> 'a -> bool) -> 'a React.signal -> 'a React.signal -> bool
  val trace :
    ?iff:bool t -> ('a -> unit) -> 'a React.signal -> 'a React.signal
  val hold :
    ?eq:('a -> 'a -> bool) -> 'a -> 'a React.event -> 'a React.signal
  val app :
    ?eq:('b -> 'b -> bool) ->
    ('a -> 'b) React.signal -> 'a React.signal -> 'b React.signal
  val map :
    ?eq:('b -> 'b -> bool) ->
    ('a -> 'b) -> 'a React.signal -> 'b React.signal
  val filter :
    ?eq:('a -> 'a -> bool) ->
    ('a -> bool) -> 'a -> 'a React.signal -> 'a React.signal
  val fmap :
    ?eq:('b -> 'b -> bool) ->
    ('a -> 'b option) -> 'b -> 'a React.signal -> 'b React.signal
  val diff : ('a -> 'a -> 'b) -> 'a React.signal -> 'b React.event
  val changes : 'a React.signal -> 'a React.event
  val sample :
    ('b -> 'a -> 'c) -> 'b React.event -> 'a React.signal -> 'c React.event
  val on :
    ?eq:('a -> 'a -> bool) ->
    bool React.signal -> 'a -> 'a React.signal -> 'a React.signal
  val when_ :
    ?eq:('a -> 'a -> bool) ->
    bool React.signal -> 'a -> 'a React.signal -> 'a React.signal
  val dismiss :
    ?eq:('a -> 'a -> bool) ->
    'b React.event -> 'a -> 'a React.signal -> 'a React.signal
  val accum :
    ?eq:('a -> 'a -> bool) -> ('a -> 'a) React.event -> 'a -> 'a React.signal
  val fold :
    ?eq:('a -> 'a -> bool) ->
    ('a -> 'b -> 'a) -> 'a -> 'b React.event -> 'a React.signal
  val merge :
    ?eq:('a -> 'a -> bool) ->
    ('a -> 'b -> 'a) -> 'a -> 'b React.signal list -> 'a React.signal
  val switch :
    ?eq:('a -> 'a -> bool) -> 'a React.signal React.signal -> 'a React.signal
  val bind :
    ?eq:('b -> 'b -> bool) ->
    'a React.signal -> ('a -> 'b React.signal) -> 'b React.signal
  val fix :
    ?eq:('a -> 'a -> bool) ->
    'a -> ('a React.signal -> 'a React.signal * 'b) -> 'b
  val l1 :
    ?eq:('b -> 'b -> bool) ->
    ('a -> 'b) -> 'a React.signal -> 'b React.signal
  val l2 :
    ?eq:('c -> 'c -> bool) ->
    ('a -> 'b -> 'c) -> 'a React.signal -> 'b React.signal -> 'c React.signal
  val l3 :
    ?eq:('d -> 'd -> bool) ->
    ('a -> 'b -> 'c -> 'd) ->
    'a React.signal -> 'b React.signal -> 'c React.signal -> 'd React.signal
  val l4 :
    ?eq:('e -> 'e -> bool) ->
    ('a -> 'b -> 'c -> 'd -> 'e) ->
    'a React.signal ->
    'b React.signal -> 'c React.signal -> 'd React.signal -> 'e React.signal
  val l5 :
    ?eq:('f -> 'f -> bool) ->
    ('a -> 'b -> 'c -> 'd -> 'e -> 'f) ->
    'a React.signal ->
    'b React.signal ->
    'c React.signal -> 'd React.signal -> 'e React.signal -> 'f React.signal
  val l6 :
    ?eq:('g -> 'g -> bool) ->
    ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g) ->
    'a React.signal ->
    'b React.signal ->
    'c React.signal ->
    'd React.signal -> 'e React.signal -> 'f React.signal -> 'g React.signal
  module Bool = React.S.Bool
  module Int = React.S.Int
  module Float = React.S.Float
  module Pair = React.S.Pair
  module Option = React.S.Option
  module Compare = React.S.Compare
  module type EqType = sig type 'a t val equal : 'a t -> 'a t -> bool end
  module type S =
    sig
      type 'a v
      val create :
        'a v -> 'a v React.signal * (?step:React.step -> 'a v -> unit)
      val equal : 'a v React.signal -> 'a v React.signal -> bool
      val hold : 'a v -> 'a v React.event -> 'a v React.signal
      val app :
        ('a -> 'b v) React.signal -> 'a React.signal -> 'b v React.signal
      val map : ('a -> 'b v) -> 'a React.signal -> 'b v React.signal
      val filter :
        ('a v -> bool) -> 'a v -> 'a v React.signal -> 'a v React.signal
      val fmap :
        ('a -> 'b v option) -> 'b v -> 'a React.signal -> 'b v React.signal
      val when_ :
        bool React.signal -> 'a v -> 'a v React.signal -> 'a v React.signal
      val dismiss :
        'b React.event -> 'a v -> 'a v React.signal -> 'a v React.signal
      val accum : ('a v -> 'a v) React.event -> 'a v -> 'a v React.signal
      val fold :
        ('a v -> 'b -> 'a v) -> 'a v -> 'b React.event -> 'a v React.signal
      val merge :
        ('a v -> 'b -> 'a v) ->
        'a v -> 'b React.signal list -> 'a v React.signal
      val switch : 'a v React.signal React.signal -> 'a v React.signal
      val bind :
        'b React.signal -> ('b -> 'a v React.signal) -> 'a v React.signal
      val fix : 'a v -> ('a v React.signal -> 'a v React.signal * 'b) -> 'b
      val l1 : ('a -> 'b v) -> 'a React.signal -> 'b v React.signal
      val l2 :
        ('a -> 'b -> 'c v) ->
        'a React.signal -> 'b React.signal -> 'c v React.signal
      val l3 :
        ('a -> 'b -> 'c -> 'd v) ->
        'a React.signal ->
        'b React.signal -> 'c React.signal -> 'd v React.signal
      val l4 :
        ('a -> 'b -> 'c -> 'd -> 'e v) ->
        'a React.signal ->
        'b React.signal ->
        'c React.signal -> 'd React.signal -> 'e v React.signal
      val l5 :
        ('a -> 'b -> 'c -> 'd -> 'e -> 'f v) ->
        'a React.signal ->
        'b React.signal ->
        'c React.signal ->
        'd React.signal -> 'e React.signal -> 'f v React.signal
      val l6 :
        ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g v) ->
        'a React.signal ->
        'b React.signal ->
        'c React.signal ->
        'd React.signal ->
        'e React.signal -> 'f React.signal -> 'g v React.signal
    end
  module Make = React.S.Make
  module Special = React.S.Special
  module Lwt = React.S.Lwt
  val create :
    ?eq:('a -> 'a -> bool) ->
    ?default:('a Eliom_csreact.React.signal *
              (?step:Eliom_csreact.React.step -> 'a -> unit))
             option ->
    ?reset_default:bool ->
    'a ->
    'a Eliom_csreact.React.signal *
    (?step:Eliom_csreact.React.step -> 'a -> unit)
end >>